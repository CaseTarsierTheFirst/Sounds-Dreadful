// mode_level_ctrl.sv
// Two states: 0=SNR, 1=dBA_rel. KEY1: capture ambient & enter dBA; KEY2: reset->SNR.

module mode_level_ctrl #(
  parameter int N = 16,
  parameter int EMA_SHIFT = 10   // averaging for power (2^10 ≈ 1024 samples)
)(
  input  logic                clk,          // same as samp_valid domain (AUD_BCLK)
  input  logic                samp_valid,   // 1-cycle strobe per new sample
  input  logic signed [N-1:0] sample_data,  // from mic_load
  input  logic                KEY1,         // active-low: capture ambient & enter dBA
  input  logic                KEY2,         // active-low: reset to SNR, clear dBA ref
  // SNR side (hook your existing KEY0-based snr_calc here if you like)
  input  logic [7:0]          snr_db_in,    // SNR to show when in SNR mode
  output logic [7:0]          disp_db,      // value to display (SNR or dBA_rel)
  output logic                mode_is_dba   // 0=SNR, 1=dBA
);

  // -------- Power EMA (reuse for A-weighted path; currently passthrough “A-ish”) --------
  logic [31:0] x2;
  always_ff @(posedge clk) if (samp_valid)
    x2 <= $signed(sample_data) * $signed(sample_data);
  logic [47:0] pwr;
  always_ff @(posedge clk) if (samp_valid)
    pwr <= pwr - (pwr >> EMA_SHIFT) + {16'd0, x2};

  // -------- Button sync + edge detect (active-low buttons) --------
  logic b1_0, b1_1, b1_q;
  logic b2_0, b2_1, b2_q;
  always_ff @(posedge clk) begin
    b1_0 <= ~KEY1; b1_1 <= b1_0; b1_q <= b1_1; // high on press
    b2_0 <= ~KEY2; b2_1 <= b2_0; b2_q <= b2_1;
  end
  wire press1 = b1_1 & ~b1_q;
  wire press2 = b2_1 & ~b2_q;

  // -------- Mode + dBA reference handling --------
  // dBA_ref is the ambient power captured on KEY1 press (avoid 0)
  logic [47:0] dba_ref;
  always_ff @(posedge clk) begin
    if (press2) begin
      mode_is_dba <= 1'b0;       // reset to SNR mode
      dba_ref     <= 48'd1;      // clear ref
    end else if (press1) begin
      mode_is_dba <= 1'b1;       // enter dBA mode
      dba_ref     <= (pwr == 0) ? 48'd1 : pwr;
    end
  end

  // -------- log2 helper (Q8.8), same as in snr_calc but local copy --------
  function automatic [15:0] log2_q8 (input [47:0] v);
    int i;
    logic [7:0]  msb;
    int unsigned sh;
    logic [47:0] norm;
    logic [7:0]  frac;
    begin
      if (v == 0) begin
        log2_q8 = 16'd0;
      end else begin
        msb = 8'd0;
        for (i=47; i>=0; i=i-1) if (v[i]) begin msb = i[7:0]; break; end
        sh   = 47 - msb;
        norm = v << sh;
        frac = norm[46:39];
        log2_q8 = {msb, frac};       // Q8.8
      end
    end
  endfunction

  // -------- dBA_rel compute: 10*log10(P/Aref) ≈ 3.01*(log2(P)-log2(Aref)) --------
  logic [15:0] l2P, l2R, l2D, db_q8;
  logic [31:0] mult_tmp;
  always_ff @(posedge clk) begin
    l2P      <= log2_q8(pwr);
    l2R      <= log2_q8(dba_ref);
    l2D      <= l2P - l2R;
    mult_tmp <= l2D * 32'd773;     // ~3.019
    db_q8    <= mult_tmp[23:8];
  end
  logic [7:0] dba_db;
  always_comb begin
    if ($signed(db_q8[15:8]) < 0) dba_db = 8'd0; else dba_db = db_q8[15:8];
  end

  // -------- Output mux --------
  always_comb begin
    disp_db = mode_is_dba ? dba_db : snr_db_in;
  end

endmodule
